# 命令的标准模式

此文件定义了所有命令应遵循的通用模式，以保持一致性和简单性。

## 核心原则

1. **快速失败** - 检查关键先决条件，然后继续
2. **信任系统** - 不要过度验证很少失败的事情
3. **清晰的错误** - 当出错时，准确说明是什么以及如何修复
4. **最小输出** - 显示重要的内容，跳过装饰

## 标准验证

### 最小预检
只检查绝对必要的内容：
```markdown
## 快速检查
1. 如果命令需要特定目录/文件：
   - 检查它是否存在：`test -f {file} || echo "❌ {file} 未找到"`
   - 如果缺失，告诉用户修复的确切命令
2. 如果命令需要 GitHub：
   - 假设 `gh` 已认证（通常是的）
   - 仅在实际失败时检查
```

### 日期时间处理
```markdown
获取当前日期时间：`date -u +"%Y-%m-%dT%H:%M:%SZ"`
```
不要重复完整说明 - 只需引用一次 `/rules/datetime.md`。

### 错误消息
保持简短且可操作：
```markdown
❌ {什么失败了}: {确切的解决方案}
示例："❌ Epic 未找到：运行 /pm:prd-parse feature-name"
```

## 标准输出格式

### 成功输出
```markdown
✅ {动作} 完成
  - {关键结果 1}
  - {关键结果 2}
下一步：{单个建议操作}
```

### 列表输出
```markdown
找到 {count} 个 {items}：
- {item 1}：{关键详情}
- {item 2}：{关键详情}
```

### 进度输出
```markdown
{动作}... {current}/{total}
```

## 文件操作

### 检查并创建
```markdown
# 不要请求权限，只需创建所需的内容
mkdir -p .claude/{directory} 2>/dev/null
```

### 带回退的读取
```markdown
# 尝试读取，如果缺失则继续
if [ -f {file} ]; then
  # 读取并使用文件
else
  # 使用合理的默认值
fi
```

## GitHub 操作

### 信任 gh CLI
```markdown
# 不要预先检查认证，只需尝试操作
gh {command} || echo "❌ GitHub CLI 失败。运行：gh auth login"
```

### 简单的 Issue 操作
```markdown
# 一次调用获取所需内容
gh issue view {number} --json state,title,body
```

## 要避免的常见模式

### 不要：过度验证
```markdown
# 坏 - 检查太多
1. 检查目录是否存在
2. 检查权限
3. 检查 git 状态
4. 检查 GitHub 认证
5. 检查速率限制
6. 验证每个字段
```

### 要：检查要点
```markdown
# 好 - 只需要的内容
1. 检查目标是否存在
2. 尝试操作
3. 清晰地处理失败
```

### 不要：详细输出
```markdown
# 坏 - 信息太多
🎯 正在开始操作...
📋 正在验证先决条件...
✅ 步骤 1 完成
✅ 步骤 2 完成
📊 统计：...
💡 提示：...
```

### 要：简洁输出
```markdown
# 好 - 只有结果
✅ 完成：创建了 3 个文件
失败：auth.test.js（语法错误 - 第 42 行）
```

### 不要：问太多问题
```markdown
# 坏 - 太交互式
"继续？(yes/no)"
"覆盖？(yes/no)"
"你确定吗？(yes/no)"
```

### 要：智能默认值
```markdown
# 好 - 使用合理的默认值继续
# 仅在破坏性或模糊时询问
"这将删除 10 个文件。继续？(yes/no)"
```

## 快速参考

### 仅必要的工具
- 读取/列表操作：`Read, LS`
- 文件创建：`Read, Write, LS`
- GitHub 操作：添加 `Bash`
- 复杂分析：添加 `Task`（谨慎使用）

### 状态指示器
- ✅ 成功（谨慎使用）
- ❌ 错误（始终带解决方案）
- ⚠️ 警告（仅在需要操作时）
- 正常输出不使用表情符号

### 退出策略
- 成功：简短确认
- 失败：清晰的错误 + 确切的修复
- 部分：显示什么成功了，什么没有

## 记住

**简单不是简陋** - 我们仍然正确处理错误，只是不尝试防止每种可能的边缘情况。我们相信：
- 文件系统通常有效
- GitHub CLI 通常已认证
- Git 仓库通常有效
- 用户知道他们在做什么

专注于正常路径，出错时优雅地失败。